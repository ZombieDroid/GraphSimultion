<!DOCTYPE html>
<html>
<head>
<script>
class PriorityQueue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 10;
       }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
   }

   // Helper function to display all values while developing
   display() { console.log(this.container); }

   // Checks if queue is empty
   isEmpty() { return this.container.length === 0; }

   // checks if queue is full
   isFull() { return this.container.length >= this.maxSize; }

   enqueue(data, priority) {
        // Check if Queue is full
        if (this.isFull()) {
            console.log("Queue Overflow!");
            return;
        }
        let currElem = new this.Element(data, priority);
        let addedFlag = false;
        // Since we want to add elements to end, we'll just push them.
        for (let i = 0; i < this.container.length; i++) {
            if (currElem.priority >= this.container[i].priority) {
                this.container.splice(i, 0, currElem);
                addedFlag = true; break;
            }
        }
        if (!addedFlag) {
            this.container.push(currElem);
        }
    }

    dequeue() {
        // Check if empty
        if (this.isEmpty()) {
            console.log("Queue Underflow!");
            return;
        }
        return this.container.pop();
    }

    peek() {
        if (isEmpty()) {
            console.log("Queue Underflow!");
            return;
        }
        return this.container[this.container.length - 1];
    }

    clear() { this.container = []; }
}

PriorityQueue.prototype.Element = class {
    constructor(data, priority) {
        this.data = data;
        this.priority = priority;
    }
};

class Node {
    constructor(label){
        this.label = label;
        this.edges = new Map();
    }

    addEdge(node, weight){
        if(!this.edges.has(node)){
            this.edges.set(node,weight);
            node.addEdge(this, weight);
        }
    }
}

Node.prototype.toString = function(){
    return this.label;
};

function dijkstra(graph, source, target) {
    let distances = new Map();
    let prev = new Map();
    let pq = new PriorityQueue(graph.length*graph.length);

    graph.forEach(node => {
      if (node !== source) {
          distances.set(node,Infinity);
      }else{
          distances.set(node,0);
      }
      pq.enqueue(node, distances.get(node));
      prev.set(node,null);
    });

    while (!pq.isEmpty()) {
        let currNode = pq.dequeue().data;
        if(currNode === target){
            break;
        }
        currNode.edges.forEach((weight,neighbor) => {
            let alt = distances.get(currNode) + weight;
            if(distances.get(currNode) === Infinity){
                alt = weight;
            }
            if (alt < distances.get(neighbor)) {
                distances.set(neighbor,alt);
                prev.set(neighbor,currNode);
                pq.enqueue(neighbor, distances.get(neighbor));
            }
        });
    }
    let reversePath = [];
    let tmpNode = target;
    if(prev.get(tmpNode) !== null || tmpNode === source){
        while(tmpNode !== null){
            reversePath.push(tmpNode);
            tmpNode = prev.get(tmpNode);
        }
    }

    return reversePath.reverse();
}

var g = [];
var nodeA = new Node("A");
g.push(nodeA);
var nodeB = new Node("B");
g.push(nodeB);
var nodeC = new Node("C");
g.push(nodeC);
var nodeD = new Node("D");
g.push(nodeD);
var nodeE = new Node("E");
g.push(nodeE);
var nodeF = new Node("F");
g.push(nodeF);
var nodeG = new Node("G");
g.push(nodeG);

nodeA.addEdge(nodeC, 100);
nodeA.addEdge(nodeB, 3);
nodeA.addEdge(nodeD, 4);
nodeD.addEdge(nodeC, 3);
nodeD.addEdge(nodeE, 8);
nodeE.addEdge(nodeF, 10);
nodeB.addEdge(nodeG, 9);
nodeE.addEdge(nodeG, 50);

console.log(dijkstra(g, nodeA, nodeF));

</script>
</head>
<body>

</body>
</html>