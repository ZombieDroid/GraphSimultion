<!DOCTYPE html>
<html>
<head>
<script>
class PriorityQueue {
   constructor(maxSize) {
      // Set default max size if not provided
      if (isNaN(maxSize)) {
         maxSize = 10;
       }
      this.maxSize = maxSize;
      // Init an array that'll contain the queue values.
      this.container = [];
   }

   // Helper function to display all values while developing
   display() { console.log(this.container); }

   // Checks if queue is empty
   isEmpty() { return this.container.length === 0; }

   // checks if queue is full
   isFull() { return this.container.length >= this.maxSize; }

   enqueue(data, priority) {
        // Check if Queue is full
        if (this.isFull()) {
            console.log("Queue Overflow!");
            return;
        }
        let currElem = new this.Element(data, priority);
        let addedFlag = false;
        // Since we want to add elements to end, we'll just push them.
        for (let i = 0; i < this.container.length; i++) {
            if (currElem.priority < this.container[i].priority) {
                this.container.splice(i, 0, currElem);
                addedFlag = true; break;
            }
        }
        if (!addedFlag) {
            this.container.push(currElem);
        }
    }

    dequeue() {
        // Check if empty
        if (this.isEmpty()) {
            console.log("Queue Underflow!");
            return;
        }
        return this.container.pop();
    }

    peek() {
        if (isEmpty()) {
            console.log("Queue Underflow!");
            return;
        }
        return this.container[this.container.length - 1];
    }

    clear() { this.container = []; }
}

PriorityQueue.prototype.Element = class {
    constructor(data, priority) {
        this.data = data;
        this.priority = priority;
    }
};

class Node {
    constructor(label){
        this.label = label;
        this.edges = new Map();
    }

    addEdge(node, weight){
        if(!this.edges.has(node)){
            this.edges.set(node,weight);
            node.addEdge(this, weight);
        }
    }

    getEdgeWeight(node){
        return this.edges.get(node);
    }
}

function dijkstra(graph, source, target) {
    let distances = new Map();
    let prev = new Map();
    let pq = new PriorityQueue(graph.length*graph.length);

    distances[source] = 0;
    //pq.enqueue(source, 0);
    graph.forEach(node => {
      if (node !== source) {
          distances.set(node,Infinity);
      }
      pq.enqueue(node);
      prev.set(node,null);
   });

   while (!pq.isEmpty()) {
        let currNode = pq.dequeue().data;
        currNode.edges.forEach((weight,neighbor) => {
            let alt = distances[currNode] + weight;
            if(distances[currNode] == Infinity){
                alt = weight;
            }
            if (alt < distances[neighbor]) {
                distances.set(neighbor,alt);
                prev.set(neighbor,currNode);
                pq.enqueue(neighbor, distances[neighbor]);
            }
        });
   }
   console.log(distances);
   console.log(prev);
   return [distances,prev];
}

var g = new Array();
var nodeA = new Node("A");
g.push(nodeA);
var nodeB = new Node("B");
g.push(nodeB);
var nodeC = new Node("C");
g.push(nodeC);
var nodeD = new Node("D");
g.push(nodeD);
var nodeE = new Node("E");
g.push(nodeE);
var nodeF = new Node("F");
g.push(nodeF);
var nodeG = new Node("G");
g.push(nodeG);

nodeA.addEdge(nodeC, 100);
nodeA.addEdge(nodeB, 3);
nodeA.addEdge(nodeD, 4);
nodeD.addEdge(nodeC, 3);
nodeD.addEdge(nodeE, 8);
nodeE.addEdge(nodeF, 10);
nodeB.addEdge(nodeG, 9);
nodeE.addEdge(nodeG, 50);

console.log(dijkstra(g, nodeA, nodeA));

</script>
</head>
<body>

</body>
</html>